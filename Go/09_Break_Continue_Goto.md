# break, continue, goto 문

코드를 짜다보면 '제어문'이 필요할 때가 있습니다. 특히, 제어문은 반복문에서 대부분 사용됩니다. 왜냐하면, 반복문을 사용하다보면 같은 구문을 반복해서 계속 실행하기 때문에 이를 제어할 상황이 오기 때문입니다.

예를 들어 "1부터 10까지 계속 순차적으로 출력하다가 3의 배수는 건너뛰어", "1부터 10까지 출력하다가 4가 되면 반복문을 빠져나와",  "1부터 10까지 출력하다가 4가 되면 50부터 80을 출력하는 부분(레이블)으로 가"와 같은 상황이 있을 수 있습니다.

이렇게 쓰이는 제어문은 바로 **반복문을 탈출하는 break, 반복문의 첫부분으로 돌아가는 continue, 특정 부분으로 갈 수 있는 goto** 입니다.





## 이곳을 빠져나와! - break

break문은 쉽게 말해 **해당 부분을 빠져나오는 용법**입니다. '해당 부분'이라고 표현한 이유는 break는 꼭 for문뿐만이 아니라, switch문과 select문에서도 사용할 수 있기 때문입니다. for문과 동일하게 모든 용법에서 그 쓰임이 동일합니다. 하지만 제어문 자체가 반복문에서 많이 쓰이기 때문에 반복문에서의 쓰임을 중심으로 설명하겠습니다.

- 첫 번째로, break문은 '직속 for문'을 빠져나오게 해줍니다. 여러 for문이 중첩돼 있는 상황일 때 break문을 쓰면 break문이 있는 for문만 빠져나오게 됩니다. 그리고 해당 for문을 빠져나온 뒤 바로 다름 문장을 실행시킵니다.
-  두 번째로,  break문은 보통 단독으로 사용되지만, 경우에 따라 "break 레이블이름"과 같이 사용되어 지정된 레이블로 이동할 수 있습니다. 쉽게 말해서 해당 for문을 빠져나옴과 동시에 지정한 레이블로 이동한다는 뜻입니다. 여기서 주의해야할 점이 있습니다. 소제목으로 '똑똑한 break'라고 소개했는데, "break 레이블이름"으로 되어있을 때 직속 for문을 빠져나와 해당 레이블로 이동하고 **break문이 바로 빠져나왔던 for문 다음 문장을 실행**하게 합니다.  

아래의 예시를 보고 흐름을 따라간다면 언뜻 무한 루프를 돌 것 같습니다. 하지만 실제로는 "End"를 출력하고 프로그램을 종료합니다. 이는 `break TEST1`문이 for루프를 빠져나와 TEST1 레이블로 이동한 후, break가 현재 for루프를 건너 뛰고 다음 문장인 `fmt.Println("End")`로 이동하기 때문입니다.

```go
package main

import "fmt"

func main() {
	i := 0

TEST1:
	for {
		if i == 0 {
break TEST1
		}
	}
	
	fmt.Println("End")
}
```





## 원하는 조건을 걸러주는 continue

continue문은 소제목에서 보여주다시피 명시한 조건을 이용해 걸러주는 기능을 합니다. continue문은 break문과 다르게 for문과 연관돼서 사용해야만합니다. 왜냐하면 continue문을 만나면 해당 반복문의 조건검사(반복문의 처음) 부분으로 다시 이동하기 때문입니다.

아래의 예제는 숫자가 1부터 1씩 커질 때 짝수는 걸러서 15까지 출력하는 코드입니다.

```go
package main

import "fmt"

func main() {

	for i := 1; i < 16; i++ {
		if i%2 == 0 {
			continue //반복문 처음 부분으로 간다
		}
		
		fmt.Printf("%d ", i)
	}
}
```







## 그 곳으로 바로 가줘! - 하지만 잘 안 쓰이는 goto

goto는 그 이름이 의미하듯이 프로그램의 흐름을 원하는 위치로 이동시킬 때 사용하는 키워드입니다. 위치는 레이블로 표시하는데 **"goto 레이블명"을 입력하면 해당 레이블로 흐름이 이동하게 됩니다.** 아주 오래전에는 goto의 필요성에 대한 논쟁도 있었지만, 요즘엔 goto의 사용에 부정적인 분위기 입니다. 실제로 근래에 출간되는 프로그래밍 언어 서적중에는 goto를 아예 언급조차 하지 않는 서적도 있을 정도입니다.

goto를 부정적으로 보는 이유는 '프로그램의 자연스러운 흐름을 방해한다'는 것입니다. 프로그램에 있어서 흐름은 굉장히 중요하기 때문입니다. 그렇다고 해서 꼭 goto문을 써야만 해결할 수 있는 문제 상황도 딱히 존재 하지 않습니다.

사용하지 않을 거라면 그냥 넘어가도 됩니다. 하지만 알고 사용하지 않는 것과 모르고 사용하지 않는 것에는 차이가 있습니다. 그래서 간단하게 아래 예시를 통해 배워보겠습니다.

```go
package main

import "fmt"

func main() {
	var num int

	fmt.Print("자연수를 입력하세요:")
	fmt.Scanln(&num)

	if num == 1 {
		goto ONE
	} else if num == 2 {
		goto TWO
	} else {
		goto OTHER
	}

ONE:
	fmt.Print("1을 입력했습니다.\n")
	goto END
TWO:
	fmt.Print("2를 입력했습니다.\n")
	goto END
OTHER:
	fmt.Print("1이나 2를 입력하지 않으셨습니다!\n")
END:
}
```





## 실습

**두 수를 더하면 99**

반복문 안에서 if문과 continue를 적절하게 이용하는 연습을 해봅니다.

10의 자리가 A이고 1의 자리가 B인 두 자릿수와, 10의 자리가 B이고 1의 자리가 A인 두 자릿수가 더해서 99가 나오는 모든 수를 출력해봅니다.

- AB + BA = 99

- A와 B는 다른 숫자입니다. 따라서 33 + 66 = 99는 잘못된 출력입니다.
- 가능한 모든 경우의 수를 출력합니다.
- 이중 반복문을 사용합니다.
- 1의 자리에 0을 출력할 수 있습니다.

```go
package main

import "fmt"

func main() {
	var result int
	
	for A := 0; A < 10; A++ {
		for B := 0; B < 10; B++ {
			result = (A*10 + B) + (B*10 + A)
			if result != 99 {
				continue
			}
			fmt.Printf("%d%d + %d%d = %d\n", A, B, B, A, result)
		}
	}
}
```

