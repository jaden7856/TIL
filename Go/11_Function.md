# Go언어에서의 함수
함수는 특정 기능을 위해 만든 여러 문장을 묶어서 실행하는 코드 블록 단위입니다. 쉽게 말해, 프로그램의 특정 기능들을 기능별로 묶어 구현해 놓은 것입니다. 그렇기 때문에 코드의 양이 많아질수록 함수는 필수이고, 얼마나 함수를 잘 활용하였는지에 따라 프로그램의 가치가 많이 달라집니다.

Go언어에서는 함수를 다양한 방법으로 활용할 수 있도록 쓰임새를 유연하게 만들었습니다. 하지만 역시 Go언어의 개발자들은 가독성 좋은 코드를 지향하기 때문에 몇 가지 지켜야 할 문법들도 있습니다. 기본적인 형태의 함수 선언은 "func 함수이름 (매개변수이름 매개변수형) 반환형"입니다. 형식과 함께 기본적인 특징을 알아보겠습니다. 

---

- 함수를 선언할 때 쓰는 키워드는 'func'이다.
- '반환형'이 괄호(()) 뒤에 명시된다. 물론 '매개변수형'도 '매개변수이름' 뒤에 명시된다.
- 함수는 패키지 안에서 정의되고 호출되는 함수가 꼭 호출하는 함수 앞에 있을 필요는 없다. 
- '반환값'이 여러 개일 수 있다. 이럴 때는 '반환형'을 괄호로 묶어 개수만큼 입력해야한다. **((반환형1, 반환형2)**형식, 두 형이 같더라도 두 번 써야 한다)
- 블록 시작 브레이스({)가 함수 선언과 동시에 첫 줄에 있어야 한다(모든 용법을 이렇게 쓰는 것이 좋습니다).

다른 언어들은 '반환형'을 괄호 앞에 쓰는 경우가 많습니다. 괄호 뒤에 적을 수 있도록 주의해야합니다. 그리고 C언어와 같은 절차 지향언어에서는 호출되는 함수가 꼭 호출하는 함수 앞에 있어야 했습니다. 적어도 빈껍데기 선언이라도 해야합니다. 하지만 Go언어는 객체 지향을 따르는 언어이기 때문에 꼭 앞에 명시하지 않아도 됩니다. 또한, 함수에 매개변수 쓰지 않거나 여러 개 쓸 수 있다는 것은 익숙할것입니다. 여기서 특이한 점은 Go언어에서는 반환 값도 여러 개일 수 있다는 것입니다.

함수는 기본적으로 매개변수와 리턴 값의 유 무에 따라서 네 개의 형태로 나눌 수 있습니다.
이 형태들을 보여주는 아래에 함수의 기본 활용 코드를 바로 실행해보세요.

```go
package main

import "fmt"

/*기능들만 모아놓은 함수들*/
func guide() { //매개변수 X 반환 값 X
	fmt.Println("두 정수를 입력받고 곱한 결과를 출력하는 프로그램입니다.\n두 정수를 차례로 띄어 써주세요.")
	fmt.Print("두 정수를 입력해주세요 :")
}

func input() (int, int) { //매개변수 X 반환 값 O(두 개)
	var a, b int
	fmt.Scanln(&a, &b)
	return a, b
}

func multi(a, b int) int { //매개변수 O, 반환 값 O
	return a * b
}

func printResult(num int) { //매개변수 O, 반환 값 X
	fmt.Printf("결과값은 %d입니다. 프로그램을 종료합니다.\n", num)
}

func main() { //간결해진 main문
	guide()
	num1, num2 := input()
	result := multi(num1, num2)
	printResult(result)
}
```
<br>
<br>

## 전역변수와 지역변수
매개변수는 값 자체를 전달하는 방식(Pass by value)과 값의 주소를 전달하는 방식(Pass by reference)이 있습니다.
**매개변수에 전달하려는 변수가 어떤 유형의 변수이냐에 따라 사용 방법과 결과가 다릅니다.**

지역변수와 전역변수는 선언되는 위치에 따라 그 유형이 결정됩니다. 지역변수는 중괄호({}) 안에서 선언된 변수를 말합니다. 이렇게 선언된 지역변수는 선언된 지역 내에서만 유효합니다. 전역변수는 특정 지역(중괄호) 밖에서 선언된 변수를 말합니다. 이 변수는 지역과 관계없이 어느 곳에든 유효합니다.  따라서 이 두 변수는 두 가지에 차이점이 있습니다.

- 메모리에 존재하는 시간
- 변수에 접근할 수 있는 범위 

지역변수는 해당 지역에서 선언되는 순간 메모리가 생성되고 해당 지역을 벗어나면 자동으로 소멸됩니다.  하지만 전역변수는 코드가 시작되어 선언되는 순간 메모리가 생성되고 코드 전체가 끝날때까지 메모리를 차지하고 있습니다. 이것이 바로 '메모리에 존재하는 시간'에 대한 설명입니다. 

---

아래 지역변수에 대한 예시 코드
```go
package main

import "fmt"

func exampleFunc1() {
	var a int = 10 //지역변수 선언
	
	a++
	
	fmt.Println("exampleFunc1의 a는 ", a)
}

func exampleFunc2() {
	var b int = 20 //지역변수 선언
	var c int = 30 //지역변수 선언

	b++
	c++

	fmt.Println("b와 c는 ", b, c)
}

func main() {
	var a int = 28 //지역변수 선언

	exampleFunc1()
	exampleFunc2()

	fmt.Println("main의 a는", a)
}

```

위 코드에서는 3개의 함수에서 총 4개의 변수가 선언되고 초기화됩니다. 지역변수는 해당 지역에서만 유효하다는 것을 보여주기 위해 일부러 main 함수 안의 `a`와 `exampleFunc1` 함수 안의 `a`의 변수 이름을 똑같이 설정했습니다.

우선 main 함수가 호출되면서 지역변수 `a`가 선언되고 메모리상에 `a`라는 이름의 변수가 할당되고 28로 초기화됩니다.

https://grm-project-template-bucket.s3.ap-northeast-2.amazonaws.com/lesson/les_fHTII_1533202480591/fa888b91d492c76dce4ab19f72aa6ef23472bb9e0292e613390c3f623e5f5021.png

`var a int = 28` 다음 문장을 실행하면 바로 `exampleFunc1` 함수가 호출되고 지역변수 `a`를 선언하고 초기화를 했기 때문에 메모리 공간에는 추가로 변수 `a`가 할당되고 10으로 초기화됩니다. 하지만 이 상태는 main 함수가 종료된 상황이 아니기 때문에 main 함수 호출 시 할당된 변수 `a`도 메모리 공간에 함께 존재하게 됩니다. 위에 설명한 것처럼 지역변수는 실행되고 있는 지역에서만 유효하므로 다른 지역의 변수의 변수명과 관계없습니다. 따라서 변수명이 같으면 가린다는 느낌이 듭니다. 

https://grm-project-template-bucket.s3.ap-northeast-2.amazonaws.com/lesson/les_fHTII_1533202480591/e196ad0833150049d60612b65fe573237d8b470a701309e6505520af6086382b.png

그리고 `exampleFunc1`의 코드를 차례로 실행하고 함수가 종료되면 `exampleFunc1` 함수에서 선언된 변수 `a`는 메모리 공간에서 사라지게 됩니다. 그래서 메모리 공간에는 main 함수의 변수 `a`만 남게됩니다. 그리고나서 코드의 흐름은 다시 main 함수로 돌아와 `exampleFunc2` 함수를 호출합니다. `exmapleFunc2` 함수 역시 지역변수 `b`와 `c`를 선언해 메모리 공간에 변수 `b`와 `c`가 각각 할당되고 20, 30으로 초기화 됩니다.

https://grm-project-template-bucket.s3.ap-northeast-2.amazonaws.com/lesson/les_fHTII_1533202480591/f76293b4d67ed1d2d8c8c3d0cc21a7526e8416e97bef98fb4f5f44e4e5f8fa08.png

그리고 `exampleFunc2`의 코드를 차례로 실행하고 함수가 종료되면, 또 함수 내에서 선언했던 변수 `b`와 `c`는 소멸하게 되고 코드의 흐름이 다시 main 함수로 돌아와 a만 메모리에 남게됩니다. 그리고 main 함수도 종료되면  메모리 공간의 모든 변수가 소멸되는 것입니다.

https://grm-project-template-bucket.s3.ap-northeast-2.amazonaws.com/lesson/les_fHTII_1533202480591/d0fc557c287a00297a454e5904207d97c5c19944eb8b49af2491a79ac112a88f.png

지역변수를 이해했다면 전역변수는 수월할 것입니다. 아래 코드는 예시입니다.

```go
package main

import "fmt"

var a int = 1 //전역변수 선언

func localVar() int { //지역변수로 연산
	var a int = 10 //지역변수 선언

	a += 3

	return a
}

func globalVar() int { //전역변수로 연산
	a += 3
		
	return a
}

func main() {
	fmt.Println("지역변수 a의 연산: ", localVar())
	fmt.Println("전역변수 a의 연산: ", globalVar())
}
```

코드가 실행되고 main 함수가 호출되기 전에 전역변수로 선언한 `a`가 메모리 공간에 할당됩니다. 이 변수는 프로그램이 종료될 때까지 메모리 공간에 남아있을 것이고, 어느 지역에서든 사용할 수 있습니다. 그리고 main 함수가 호출되고 `localVar` 함수도 호출됩니다. `localVar` 함수에서 지역변수 `a`가 선언되고 10으로 초기화됩니다. 아까 말한 것처럼 전역변수와 이름이 같아도 지역변수는 해당 지역에서 유효하다고 했기 때문에 오류가 나는 것이 아니라 전역변수를 가리게 됩니다. 따라서 지역변수 `a`로 연산을 수행하고 종료합니다. 그리고 이어서 `globalVar` 함수를 호출하게되는데 이 함수에서는 변수를 선언하지 않았습니다. 전역변수는 어느 지역에서든 사용이 가능하기때문에 특별한 선언 없이 바로 전역변수를 사용해 연산을 하고 그 값을 반환합니다. 이렇게 지역변수를 활용한 함수와 전역변수를 활용한 함수의 쓰임과 원리를 확인했습니다.